<!DOCTYPE html><html lang="es"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Psychrometric Chart – by EMERYX</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css">
<style>
:root{--border:#E5E7EB;--muted:#6B7280}
body{font-family:system-ui,Segoe UI,Roboto,Arial}
.app{display:flex;height:100vh}
.sidebar{width:420px;border-right:1px solid var(--border);padding:12px;overflow:auto}
.main{flex:1;display:flex;flex-direction:column}
.toolbar{display:flex;gap:8px;align-items:center;padding:8px 12px;border-bottom:1px solid var(--border)}
.toolbar button,.toolbar select{padding:8px 10px;border:1px solid var(--border);border-radius:8px;background:#fff}
.sidebar input,
.sidebar select {
  max-width: 140px;   /* prueba 120px–160px según te guste */
  width: 100%;
}
#plot{flex:1}
.card{border:1px solid var(--border);border-radius:12px;padding:12px;margin-bottom:10px}
.card summary { cursor: pointer; font-weight: 700; font-size: 1.1rem; line-height: 1.25; }
.card-body { margin-top: 8px; }
.grid{display:grid;gap:8px}.cols-2{grid-template-columns:1fr 1fr}
.row{display:flex;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px dashed var(--border)}.row:last-child{border-bottom:none}
.badge{padding:2px 6px;border-radius:6px;border:1px solid var(--border);font-size:10px}
.muted{color:var(--muted);font-size:12px}
.actions button{padding:6px 10px;border:1px solid var(--border);border-radius:8px;background:#fff;font-size:12px}
.selected{background:#F3F4F6;outline:2px solid #11182722}

@media print{
  /* oculta todo salvo #printArea */
  body > *:not(#printArea){ display:none !important; }
  #printArea{ display:block !important; }

  /* tamaño y márgenes “de impresora” */
  @page{ size:A4; margin:12mm; }

  /* cada sección será una página */
  .print-page{ break-after:page; }
  /* para la última página no forzar salto (por si el visor añade una blanca extra) */
  .print-page:last-child{ break-after:auto; }

  /* imagen de la gráfica ocupando el ancho útil */
  .print-plot img{ width:100%; height:auto; display:block; }

  /* tablas legibles */
  .print-table{ width:100%; border-collapse:collapse; font-size:11pt; }
  .print-table th, .print-table td{ border:1px solid #ccc; padding:6px 8px; }
  .print-table th{ background:#f3f4f6; text-align:left; }
  .h1{ font-size:18pt; margin:0 0 8px; }
}
/* En pantalla, mantenemos oculto el área de impresión */
#printArea{ display:none; }

</style>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script id="i18n-embed" type="application/json">{
  "fr": {"ui.project": "Projet", "ui.conditions": "Conditions", "ui.altitude": "Altitude (m)", "ui.pressure": "Pression (kPa)", "ui.airflow": "Débit d’air (m³/h)", "ui.newState": "+ Nouvel état", "ui.name": "Nom", "ui.note": "Étiquette", "ui.tdb": "Tbs (°C)", "ui.rh_pct": "φ (%)", "btn.add": "Ajouter", "ui.newProc": "+ Nouveau processus", "ui.type": "Type", "proc.type.select": "sélectionner", "proc.type.heat": "Chauffer", "proc.type.cool": "Refroidir", "proc.type.mix": "Mélange", "proc.type.rc": "Récupération de chaleur", "proc.type.humid": "Humidifier", "ui.input": "Entrée", "ui.output": "Sortie", "btn.apply": "Appliquer", "ui.states": "États", "ui.processes": "Processus", "btn.saveJson": "Enregistrer JSON", "btn.loadJson": "Charger JSON", "btn.csv": "Exporter CSV", "btn.pdf": "Exporter PDF", "btn.jsonData": "Exporter JSON (données)", "toolbar.rh": "Courbes HR :", "toolbar.ranges": "Plages : T -10..50 °C, x 0..26 g/kg", "ui.lang": "Langue :", "btn.delete": "Supprimer", "confirm.delete": "Supprimer cet état et les processus connectés ?", "proc.label": "Processus_", "ui.rh_curves_on": "ON", "ui.rh_curves_off": "OFF","proc.field.calc_by": "Calculer par","proc.by.Q": "Puissance","proc.by.aT": "à T","proc.by.Twall": "T paroi","proc.by.hyd": "Caract. eau","proc.field.eta_cooler_pct": "Rend. batterie (%)","proc.field.dADP_K": "ΔADP (K, défaut 2)","proc.field.BFov": "BF (0..1, optionnel)","proc.cool.note_cond": "Si le processus condense : ADP≈T_sens−ΔADP (ou lié à paroi/eau), BF≈1−η sauf si vous indiquez un BF ici.","proc.field.mix_Tn": "T nouveau débit (°C)","proc.field.mix_RHn": "HR nouveau débit (%)","proc.field.mix_qNew": "Nouveau débit (m³/h)","proc.field.mix_pctUse": "% débit existant pour mélange","proc.field.T_sec": "T secondaire (°C)","proc.field.RH_sec": "HR secondaire (%)","proc.field.etaS_pct": "Efficacité thermique (%)","proc.field.etaL_pct": "Récup. d’humidité (%)","proc.field.hum_type": "Type","proc.field.hum_mode": "Mode","proc.hum.adiab": "Adiabatique","proc.hum.iso": "Isotherme","proc.hum.aRH": "à φ","proc.hum.dx": "Δx","proc.hum.mwater": "ṁ eau","proc.field.phi_pct": "φ cible (%)","proc.field.dx_gpkg": "Δx (g/kg_da)","proc.field.mw_lh": "Débit d’eau (L/h)","proc.k.dT": "ΔT","proc.k.dx": "Δx","proc.k.dh": "Δh","proc.k.m_lh": "ṁ eau","proc.k.Qtot": "Puissance totale","proc.k.Qsen": "Puissance sensible","print.title.diagram": "Diagramme psychrométrique","print.title.states": "États","print.title.procs": "Processus","print.alt.plot": "Graphique","print.states.cols.name": "Nom","print.states.cols.t": "T (°C)","print.states.cols.rh": "HR (%)","print.states.cols.x": "x (g/kg_da)","print.states.cols.h": "h (kJ/kg_da)","print.states.cols.twb": "Twb (°C)","print.states.cols.rho": "ρ (kg/m³)","print.states.cols.note": "Note","print.procs.cols.proc": "Processus","print.procs.cols.type": "Type","print.procs.cols.in": "Entrées","print.procs.cols.out": "Sortie","print.procs.cols.Qt": "Puissance totale (kW)","print.procs.cols.Qs": "Puissance sensible (kW)"},
  "es": {"ui.project": "Proyecto", "ui.conditions": "Condiciones", "ui.altitude": "Altitud (m)", "ui.pressure": "Presión (kPa)", "ui.airflow": "Caudal aire (m³/h)", "ui.newState": "+ Nuevo estado", "ui.name": "Nombre", "ui.note": "Etiqueta", "ui.tdb": "Tbs (°C)", "ui.rh_pct": "φ (%)", "btn.add": "Añadir", "ui.newProc": "+ Nuevo proceso", "ui.type": "Tipo", "proc.type.select": "seleccionar", "proc.type.heat": "Calentar", "proc.type.cool": "Enfriar", "proc.type.mix": "Mezcla", "proc.type.rc": "Recuperación de calor", "proc.type.humid": "Humidificar", "ui.input": "Entrada", "ui.output": "Salida", "btn.apply": "Aplicar", "ui.states": "Estados", "ui.processes": "Procesos", "btn.saveJson": "Guardar JSON", "btn.loadJson": "Cargar JSON", "btn.csv": "Exportar CSV", "btn.pdf": "Exportar PDF", "btn.jsonData": "Exportar JSON (datos)", "toolbar.rh": "Curvas HR:", "toolbar.ranges": "Rangos: T -10..50 °C, x 0..26 g/kg", "ui.lang": "Idioma:", "btn.delete": "Borrar", "confirm.delete": "¿Borrar este estado y procesos conectados?", "proc.label": "Proceso_", "ui.rh_curves_on": "ON", "ui.rh_curves_off": "OFF","proc.field.calc_by": "Descripción :","proc.by.Q": "Potencia","proc.by.aT": "a T","proc.by.Twall": "T pared","proc.by.hyd": "Caract. medio hyd.","proc.field.eta_cooler_pct": "Rend. batería (%)","proc.field.dADP_K": "ΔADP (K, defecto 2)","proc.field.BFov": "BF (0..1, opcional)","proc.cool.note_cond": "Si el proceso condensa: ADP≈T_sens−ΔADP (o ligado a pared/agua), BF≈1−η salvo que indiques un BF aquí.","proc.field.mix_Tn": "T nuevo caudal (°C)","proc.field.mix_RHn": "Hr nuevo caudal (%)","proc.field.mix_qNew": "Nuevo caudal (m³/h)","proc.field.mix_pctUse": "% caudal existente para mezcla","proc.field.T_sec": "T secundaria (°C)","proc.field.RH_sec": "HR secundaria (%)","proc.field.etaS_pct": "Eficiencia térmica (%)","proc.field.etaL_pct": "Recup. de humedad (%)","proc.field.hum_type": "Tipo","proc.field.hum_mode": "Modo","proc.hum.adiab": "Adiabática","proc.hum.iso": "Isotérmica","proc.hum.aRH": "a HR%","proc.hum.dx": "Δx","proc.hum.mwater": "ṁ agua","proc.field.phi_pct": "HR objetivo (%)","proc.field.dx_gpkg": "Δx (g/kg_da)","proc.field.mw_lh": "Caudal de agua (L/h)","proc.k.dT": "ΔT","proc.k.dx": "Δx","proc.k.dh": "Δh","proc.k.m_lh": "m_humedad","proc.k.Qtot": "Potencia total","proc.k.Qsen": "Potencia sensible","print.title.diagram": "Diagrama psicrométrico","print.title.states": "Estados","print.title.procs": "Procesos","print.alt.plot": "Gráfica","print.states.cols.name": "Nombre","print.states.cols.t": "T (°C)","print.states.cols.rh": "φ (%)","print.states.cols.x": "x (g/kg_da)","print.states.cols.h": "h (kJ/kg_da)","print.states.cols.twb": "Twb (°C)","print.states.cols.rho": "ρ (kg/m³)","print.states.cols.note": "Nota","print.procs.cols.proc": "Proceso","print.procs.cols.type": "Tipo","print.procs.cols.in": "Entradas","print.procs.cols.out": "Salida","print.procs.cols.Qt": "Q total (kW)","print.procs.cols.Qs": "Q sensible (kW)"},
  "en": {"ui.project": "Project", "ui.conditions": "Conditions", "ui.altitude": "Altitude (m)", "ui.pressure": "Pressure (kPa)", "ui.airflow": "Airflow (m³/h)", "ui.newState": "+ New state", "ui.name": "Name", "ui.note": "Tag", "ui.tdb": "Tdb (°C)", "ui.rh_pct": "RH (%)", "btn.add": "Add", "ui.newProc": "+ New process", "ui.type": "Type", "proc.type.select": "select", "proc.type.heat": "Heating", "proc.type.cool": "Cooling", "proc.type.mix": "Mix", "proc.type.rc": "Heat recovery", "proc.type.humid": "Humidification", "ui.input": "Input", "ui.output": "Output", "btn.apply": "Apply", "ui.states": "States", "ui.processes": "Processes", "btn.saveJson": "Save JSON", "btn.loadJson": "Load JSON", "btn.csv": "Export CSV", "btn.pdf": "Export PDF", "btn.jsonData": "Export JSON (data)", "toolbar.rh": "RH curves:", "toolbar.ranges": "Ranges: T -10..50 °C, x 0..26 g/kg", "ui.lang": "Language:", "btn.delete": "Delete", "confirm.delete": "Delete this state and connected processes?", "proc.label": "Process_", "ui.rh_curves_on": "ON", "ui.rh_curves_off": "OFF","proc.field.calc_by": "Calculate by","proc.by.Q": "Power","proc.by.aT": "to T","proc.by.Twall": "Wall T","proc.by.hyd": "Water circuit","proc.field.eta_cooler_pct": "Coil efficiency (%)","proc.field.dADP_K": "ΔADP (K, default 2)","proc.field.BFov": "BF (0..1, optional)","proc.cool.note_cond": "If condensation occurs: ADP≈T_sens−ΔADP (or linked to wall/water), BF≈1−η unless you specify a BF here.","proc.field.mix_Tn": "T new flow (°C)","proc.field.mix_RHn": "RH new flow (%)","proc.field.mix_qNew": "New flow (m³/h)","proc.field.mix_pctUse": "% existing flow for mix","proc.field.T_sec": "Secondary T (°C)","proc.field.RH_sec": "Secondary RH (%)","proc.field.etaS_pct": "Thermal efficiency (%)","proc.field.etaL_pct": "Moisture recovery (%)","proc.field.hum_type": "Type","proc.field.hum_mode": "Mode","proc.hum.adiab": "Adiabatic","proc.hum.iso": "Isothermal","proc.hum.aRH": "to RH%","proc.hum.dx": "Δx","proc.hum.mwater": "ṁ water","proc.field.phi_pct": "Target RH (%)","proc.field.dx_gpkg": "Δx (g/kg_da)","proc.field.mw_lh": "Water flow (L/h)","proc.k.dT": "ΔT","proc.k.dx": "Δx","proc.k.dh": "Δh","proc.k.m_lh": "ṁ water","proc.k.Qtot": "Total power","proc.k.Qsen": "Sensible power","print.title.diagram": "Psychrometric diagram","print.title.states": "States","print.title.procs": "Processes","print.alt.plot": "Chart","print.states.cols.name": "Name","print.states.cols.t": "T (°C)","print.states.cols.rh": "RH (%)","print.states.cols.x": "x (g/kg_da)","print.states.cols.h": "h (kJ/kg_da)","print.states.cols.twb": "Twb (°C)","print.states.cols.rho": "ρ (kg/m³)","print.states.cols.note": "Note","print.procs.cols.proc": "Process","print.procs.cols.type": "Type","print.procs.cols.in": "Inputs","print.procs.cols.out": "Output","print.procs.cols.Qt": "Total power (kW)","print.procs.cols.Qs": "Sensible power (kW)"},
  "de": {"ui.project": "Projekt", "ui.conditions": "Bedingungen", "ui.altitude": "Höhe (m)", "ui.pressure": "Druck (kPa)", "ui.airflow": "Luftvolumenstrom (m³/h)", "ui.newState": "+ Neuer Zustand", "ui.name": "Name", "ui.note": "Etikett", "ui.tdb": "Tbs (°C)", "ui.rh_pct": "rF (%)", "btn.add": "Hinzufügen", "ui.newProc": "+ Neuer Prozess", "ui.type": "Typ", "proc.type.select": "auswählen", "proc.type.heat": "Heizen", "proc.type.cool": "Kühlen", "proc.type.mix": "Mischen", "proc.type.rc": "Wärmerückgewinnung", "proc.type.humid": "Befeuchten", "ui.input": "Eingang", "ui.output": "Ausgang", "btn.apply": "Anwenden", "ui.states": "Zustände", "ui.processes": "Prozesse", "btn.saveJson": "JSON speichern", "btn.loadJson": "JSON laden", "btn.csv": "CSV exportieren", "btn.pdf": "PDF exportieren", "btn.jsonData": "JSON (Daten) exportieren", "toolbar.rh": "rF-Kurven:", "toolbar.ranges": "Bereiche: T -10..50 °C, x 0..26 g/kg", "ui.lang": "Sprache:", "btn.delete": "Löschen", "confirm.delete": "Diesen Zustand und verbundene Prozesse löschen?", "proc.label": "Prozess_", "ui.rh_curves_on": "AN", "ui.rh_curves_off": "AUS","proc.field.calc_by": "Berechnen nach","proc.by.Q": "Leistung","proc.by.aT": "auf T","proc.by.Twall": "Wand-T","proc.by.hyd": "Wasserkreis","proc.field.eta_cooler_pct": "Wirkungsgrad Batterie (%)","proc.field.dADP_K": "ΔADP (K, Standard 2)","proc.field.BFov": "BF (0..1, optional)","proc.cool.note_cond": "Wenn der Prozess kondensiert: ADP≈T_sens−ΔADP (oder an Wand/Wasser gekoppelt), BF≈1−η, außer Sie geben hier einen BF an.","proc.field.mix_Tn": "T neuer Volumenstrom (°C)","proc.field.mix_RHn": "rF neuer Volumenstrom (%)","proc.field.mix_qNew": "Neuer Volumenstrom (m³/h)","proc.field.mix_pctUse": "% vorhandener Volumenstrom für Mischung","proc.field.T_sec": "Sekundär-T (°C)","proc.field.RH_sec": "Sekundäre rF (%)","proc.field.etaS_pct": "Sensible Effizienz (%)","proc.field.etaL_pct": "Feuchterückgewinnung (%)","proc.field.hum_type": "Typ","proc.field.hum_mode": "Modus","proc.hum.adiab": "Adiabatisch","proc.hum.iso": "Isotherm","proc.hum.aRH": "auf φ","proc.hum.dx": "Δx","proc.hum.mwater": "ṁ Wasser","proc.field.phi_pct": "Ziel-rF (%)","proc.field.dx_gpkg": "Δx (g/kg_tr)","proc.field.mw_lh": "Wasserstrom (L/h)","proc.k.dT": "ΔT","proc.k.dx": "Δx","proc.k.dh": "Δh","proc.k.m_lh": "ṁ Wasser","proc.k.Qtot": "Gesamtleistung","proc.k.Qsen": "Sensible Leistung","print.title.diagram": "Psychrometrisches Diagramm","print.title.states": "Zustände","print.title.procs": "Prozesse","print.alt.plot": "Diagramm","print.states.cols.name": "Name","print.states.cols.t": "T (°C)","print.states.cols.rh": "rF (%)","print.states.cols.x": "x (g/kg_da)","print.states.cols.h": "h (kJ/kg_da)","print.states.cols.twb": "Twb (°C)","print.states.cols.rho": "ρ (kg/m³)","print.states.cols.note": "Notiz","print.procs.cols.proc": "Prozess","print.procs.cols.type": "Typ","print.procs.cols.in": "Eingänge","print.procs.cols.out": "Ausgang","print.procs.cols.Qt": "Gesamtleistung (kW)","print.procs.cols.Qs": "Sensible Leistung (kW)"},
  "it": {"ui.project": "Progetto", "ui.conditions": "Condizioni", "ui.altitude": "Altitudine (m)", "ui.pressure": "Pressione (kPa)", "ui.airflow": "Portata aria (m³/h)", "ui.newState": "+ Nuovo stato", "ui.name": "Nome", "ui.note": "Etichetta", "ui.tdb": "Tbs (°C)", "ui.rh_pct": "UR (%)", "btn.add": "Aggiungi", "ui.newProc": "+ Nuovo processo", "ui.type": "Tipo", "proc.type.select": "seleziona", "proc.type.heat": "Riscaldare", "proc.type.cool": "Raffrescare", "proc.type.mix": "Miscela", "proc.type.rc": "Recupero di calore", "proc.type.humid": "Umidificare", "ui.input": "Ingresso", "ui.output": "Uscita", "btn.apply": "Applica", "ui.states": "Stati", "ui.processes": "Processi", "btn.saveJson": "Salva JSON", "btn.loadJson": "Carica JSON", "btn.csv": "Esporta CSV", "btn.pdf": "Esporta PDF", "btn.jsonData": "Esporta JSON (dati)", "toolbar.rh": "Curve UR:", "toolbar.ranges": "Intervalli: T -10..50 °C, x 0..26 g/kg", "ui.lang": "Lingua:", "btn.delete": "Elimina", "confirm.delete": "Eliminare questo stato e i processi collegati?", "proc.label": "Processo_", "ui.rh_curves_on": "ON", "ui.rh_curves_off": "OFF","proc.field.calc_by": "Calcolare per","proc.by.Q": "Potenza","proc.by.aT": "a T","proc.by.Twall": "T parete","proc.by.hyd": "Circuito acqua","proc.field.eta_cooler_pct": "Rendimento batteria (%)","proc.field.dADP_K": "ΔADP (K, predef. 2)","proc.field.BFov": "BF (0..1, opzionale)","proc.cool.note_cond": "Se il processo condensa: ADP≈T_sens−ΔADP (o legato a parete/acqua), BF≈1−η salvo che specifichi un BF qui.","proc.field.mix_Tn": "T nuova portata (°C)","proc.field.mix_RHn": "UR nuova portata (%)","proc.field.mix_qNew": "Nuova portata (m³/h)","proc.field.mix_pctUse": "% portata esistente per miscela","proc.field.T_sec": "T secondaria (°C)","proc.field.RH_sec": "UR secondaria (%)","proc.field.etaS_pct": "Rendimento sensibile (%)","proc.field.etaL_pct": "Recupero di umidità (%)","proc.field.hum_type": "Tipo","proc.field.hum_mode": "Modalità","proc.hum.adiab": "Adiabatica","proc.hum.iso": "Isotermica","proc.hum.aRH": "a φ","proc.hum.dx": "Δx","proc.hum.mwater": "ṁ acqua","proc.field.phi_pct": "UR target (%)","proc.field.dx_gpkg": "Δx (g/kg_da)","proc.field.mw_lh": "Portata acqua (L/h)","proc.k.dT": "ΔT","proc.k.dx": "Δx","proc.k.dh": "Δh","proc.k.m_lh": "ṁ acqua","proc.k.Qtot": "Potenza totale","proc.k.Qsen": "Potenza sensibile","print.title.diagram": "Diagramma psicrometrico","print.title.states": "Stati","print.title.procs": "Processi","print.alt.plot": "Grafico","print.states.cols.name": "Nome","print.states.cols.t": "T (°C)","print.states.cols.rh": "UR (%)","print.states.cols.x": "x (g/kg_da)","print.states.cols.h": "h (kJ/kg_da)","print.states.cols.twb": "Twb (°C)","print.states.cols.rho": "ρ (kg/m³)","print.states.cols.note": "Nota","print.procs.cols.proc": "Processo","print.procs.cols.type": "Tipo","print.procs.cols.in": "Ingressi","print.procs.cols.out": "Uscita","print.procs.cols.Qt": "Potenza totale (kW)","print.procs.cols.Qs": "Potenza sensibile (kW)"}}</script>
<script>
// --- Simple i18n loader (fallback FR) ---
const I18N_FALLBACK_LANG = 'fr';
const I18N_SUPPORTED = ['es','fr','de','it','en'];
let I18N_DICT = null;
let LANG = (localStorage.getItem('lang') || (navigator.language||'fr').slice(0,2)).toLowerCase();
if(!I18N_SUPPORTED.includes(LANG)) LANG = I18N_FALLBACK_LANG;
document.documentElement.lang = LANG;

function setLang(l){
  if(!I18N_SUPPORTED.includes(l)) return;
  LANG = l;
  localStorage.setItem('lang', l);
  document.documentElement.lang = l;
  applyI18n(document);
  if (typeof renderProcParams === 'function') renderProcParams();
  if (typeof renderLists === 'function') renderLists();
}

function t(key){
  if(!I18N_DICT) return key;
  return (I18N_DICT[LANG] && I18N_DICT[LANG][key])
      || (I18N_DICT[I18N_FALLBACK_LANG] && I18N_DICT[I18N_FALLBACK_LANG][key])
      || key;
}

function applyI18n(root=document){
  root.querySelectorAll('[data-i18n]').forEach(el=>{
    const key = el.getAttribute('data-i18n');
    if(el.hasAttribute('data-i18n-html')) el.innerHTML = t(key);
    else el.textContent = t(key);
  });
  // toolbar dynamic labels (RH select values)
  const rhSel = document.getElementById('rhCurves');
  if(rhSel){
    rhSel.options[0].textContent = t('ui.rh_curves_on');
    rhSel.options[1].textContent = t('ui.rh_curves_off');
  }
}

async function loadI18n(){
  // try external JSON
  try{
    const res = await fetch('i18n.json', {cache:'no-store'});
    if(res.ok){
      I18N_DICT = await res.json();
    }else{
      throw new Error('i18n.json not reachable');
    }
  }catch(e){
    // fallback: embedded JSON <script id="i18n-embed">
    const tag = document.getElementById('i18n-embed');
    if(tag){
      try{ I18N_DICT = JSON.parse(tag.textContent); }catch(_){ I18N_DICT = null; }
    }
  }
  if(!I18N_DICT){
    console.warn('i18n dictionaries not loaded; UI texts may show keys.');
    I18N_DICT = { [I18N_FALLBACK_LANG]: {} };
  }
}

async function boot(){
  await loadI18n();
  // init app after dictionaries are available
  if(typeof init==='function'){ init(10); }
  if(typeof renderProcParams==='function'){ renderProcParams(); }
  if(typeof bind==='function'){ bind(); }
  if(typeof toggleProcUI==='function'){ toggleProcUI(); }
  applyI18n(document);

  // init language selector
  const sel = document.getElementById('langSel');
  if(sel){
    sel.value = LANG;
    sel.addEventListener('change', e=> setLang(e.target.value));
  }
}
</script>

<script>
const R=0.287042;
function Palt(h){return 101.325*Math.pow(1-2.25577e-5*h,5.2559)}
function pws(T){return (T>=0?0.61078*Math.exp(17.2694*T/(T+237.3)):0.61078*Math.exp(21.8745584*T/(T+265.5)))}
function wTRP(T,RH,P){const Pw=(RH/100)*pws(T);return 0.62198*Pw/(P-Pw)}
function hTw(T,w){return 1.006*T+w*(2501+1.86*T)}
function T_hw(h,w){const A=1.006+1.86*w,B=2501*w;return (h-B)/A}
function vTPw(T,P,w){return R*(T+273.15)*(1+1.607858*w)/P}
function solveT(hc,RH,P,lo=-20,hi=60){for(let i=0;i<50;i++){const m=(lo+hi)/2,w=wTRP(m,RH,P),h=hTw(m,w);(h>hc)?hi=m:lo=m}return (lo+hi)/2}
function Twb_from_hP(h, P){ return solveT(h, 100, P); }
let S=[], PR=[], SEL=null, ALT=400, Pk=null, ID=1, FLOW_M3H=null, PROC_SEQ=1;
function Pnow(){return (Pk&&Pk>0)?Pk:Palt(ALT)}
function addS(name,T,RH,note=""){const P=Pnow(),w=wTRP(T,RH,P),h=hTw(T,w),v=vTPw(T,P,w),rho=1/v,Twb = Twb_from_hP(h, P),s={id:"S"+(ID++),name,T,RH,P,w,h,v,rho,Twb,note};S.push(s);PR.push({id:"PX"+(ID++),type:"state",in:null,out:s.id,params:{},mdot:null,Q:0,M:0,color:"#22D3EE"});SEL=s.id;return s}
function delS(id){PR=PR.filter(p=>p.out!==id && !(Array.isArray(p.in)?p.in.includes(id):p.in===id));S=S.filter(x=>x.id!==id);if(SEL===id)SEL=null}
function updS(id,T,RH,name,note){const s=S.find(x=>x.id===id);if(!s)return;const P=Pnow();s.name=name||s.name;s.note=note||s.note;s.T=T;s.RH=RH;s.P=P;s.w=wTRP(T,RH,P);s.h=hTw(T,s.w);s.v=vTPw(T,P,s.w);s.rho=1/s.v;s.Twb = Twb_from_hP(s.h, P)}
function recalc(){for(const p of PR){if(p.type==="state"){p.Q=0;p.M=0;continue}const md=p.mdot||1;const si=S.find(s=>s.id==(Array.isArray(p.in)?p.in[0]:p.in)),so=S.find(s=>s.id===p.out);if(!si||!so){p.Q=0;p.M=0;continue}p.Q=md*(so.h-si.h);p.M=md*(so.w-si.w)}}
function mix(A,B,fA,outName="MX"){const a=S.find(s=>s.id===A),b=S.find(s=>s.id===B);if(!a||!b)return alert("Entradas inválidas");const P=Pnow(),fa=Math.max(0,Math.min(1,isFinite(+fA)?+fA:0.5)),fb=1-fa,hMix=fa*a.h+fb*b.h,wMix=fa*a.w+fb*b.w,Tmix=T_hw(hMix,wMix),Pw=(wMix*P)/(0.62198+wMix),RH=Math.max(0,Math.min(100,100*(Pw/pws(Tmix))));const st=addS(outName,Tmix,RH,"Mezcla");const seq=PROC_SEQ++;PR.push({id:"PM"+(ID++),type:"mix",badge:"mix",seq,in:[a.id,b.id],out:st.id,params:{fA:fa},mdot:0,Q:0,M:0,color:"#065F46"});return st;}
function mixWithNew(inId,Tn,RHn,qNew_m3h,pctUse100,outName="MX"){const si=S.find(s=>s.id===inId);if(!si)return alert("Entrada inválida");const P=Pnow();const wn=wTRP(Tn,RHn,P),hn=hTw(Tn,wn),rhoN=1/vTPw(Tn,P,wn);const qExist_m3s=(FLOW_M3H!=null&&FLOW_M3H>0)?(FLOW_M3H/3600):0,mdE=(qExist_m3s>0)?qExist_m3s*si.rho:0;const mdN=(qNew_m3h>0?qNew_m3h/3600:0)*rhoN;const fUse=Math.max(0,Math.min(1,(isFinite(+pctUse100)?+pctUse100:0)/100));const mdE_use=mdE*fUse;if(!(mdE_use>0)||!(mdN>0))return alert("Define % del existente (>0) y un nuevo caudal (>0).");const fE=mdE_use/(mdE_use+mdN),fN=1-fE,wMix=fE*si.w+fN*wn,hMix=fE*si.h+fN*hn,Tmix=T_hw(hMix,wMix),Pw=(wMix*P)/(0.62198+wMix),RHmix=Math.max(0,Math.min(100,100*(Pw/pws(Tmix))));const st=addS(outName,Tmix,RHmix,"Mezcla (nuevo caudal)");const seq=PROC_SEQ++;PR.push({id:"PM"+(ID++),type:"mix",badge:"mix",seq,in:[si.id],out:st.id,params:{Tn,RHn,qNew_m3h,pctUse:pctUse100},mdot:mdE_use,Q:0,M:0,color:"#065F46"});return st;}
function proc(t,inId,params,mdot=1,outName="P"){const si=S.find(s=>s.id===inId);if(!si)return alert("Entrada inválida");const P=Pnow();const q_m3s=(FLOW_M3H!=null&&FLOW_M3H>0)?(FLOW_M3H/3600):0;const md=q_m3s>0?q_m3s*si.rho:1;let T2=si.T,w2=si.w,RH2=si.RH,note="",color="#000";if(t==="heat"){const desc=params.desc||"dT";note="Calentar";color="#EF4444";if(desc==="Q"){const QkW=+params.QkW||0;const dH=md>0?QkW/md:0;const h2=si.h+dH;w2=si.w;T2=T_hw(h2,w2);}else if(desc==="dT"){const dT=+params.dT||0;T2=si.T+dT;w2=si.w;}else if(desc==="dH"){const dH=+params.dH||0;const h2=si.h+dH;w2=si.w;T2=T_hw(h2,w2);}else if(desc==="aT"){T2=isFinite(+params.Ttarget)?+params.Ttarget:si.T;w2=si.w;}else if(desc==="Twall"){const Tw=isFinite(+params.Twall)?+params.Twall:si.T;const eta=isFinite(+params.eta)?+params.eta:0.7;T2=si.T+eta*(Tw-si.T);w2=si.w;}else if(desc==="hyd"){const Tin=isFinite(+params.Tw_in)?+params.Tw_in:si.T;const Tout=isFinite(+params.Tw_out)?+params.Tw_out:Tin;const eta=isFinite(+params.eta)?+params.eta:0.7;const Tm=(Tin+Tout)/2;T2=si.T+eta*(Tm-si.T);w2=si.w;}}else if(t==="cool"){const desc=params.desc||"dT";note="Enfriar";color="#3B82F6";const etaAll=(isFinite(+params.etaAll)?+params.etaAll:0.8);let T2sens=si.T,h2sens=si.h;if(desc==="Q"){const QkW=+params.QkW||0;const dH=md>0?-(QkW/md)*etaAll:0;h2sens=si.h+dH;T2sens=T_hw(h2sens,si.w);}else if(desc==="dT"){const dT=+params.dT||0;T2sens=si.T+etaAll*dT;h2sens=hTw(T2sens,si.w);}else if(desc==="dH"){const dH=+params.dH||0;h2sens=si.h-etaAll*dH;T2sens=T_hw(h2sens,si.w);}else if(desc==="aT"){const Tt=isFinite(+params.Ttarget)?+params.Ttarget:si.T;T2sens=si.T+etaAll*(Tt-si.T);h2sens=hTw(T2sens,si.w);}else if(desc==="Twall"){const Tw=isFinite(+params.Twall)?+params.Twall:si.T;T2sens=si.T+etaAll*(Tw-si.T);h2sens=hTw(T2sens,si.w);}else if(desc==="hyd"){const Tin=isFinite(+params.Tw_in)?+params.Tw_in:si.T;const Tout=isFinite(+params.Tw_out)?+params.Tw_out:Tin;const Tm=(Tin+Tout)/2;T2sens=si.T+etaAll*(Tm-si.T);h2sens=hTw(T2sens,si.w);}const w_sat_sens=wTRP(T2sens,100,P);if(si.w<=w_sat_sens+1e-9){T2=T2sens;w2=si.w;}else{let BF=isFinite(+params.BFov)?+params.BFov:Math.max(0,Math.min(0.95,1-etaAll));const dADP=(isFinite(+params.dADP)?+params.dADP:2);let ADP=T2sens-dADP;if(desc==="Twall"){const Tw=isFinite(+params.Twall)?+params.Twall:si.T;ADP=Math.max(Tw,ADP);}else if(desc==="hyd"){const Tin=isFinite(+params.Tw_in)?+params.Tw_in:si.T;const Tout=isFinite(+params.Tw_out)?+params.Tw_out:Tin;const Twmin=Math.min(Tin,Tout);ADP=Math.min(T2sens-0.1,Twmin+dADP);}const w_adp=wTRP(ADP,100,P),h_adp=hTw(ADP,w_adp),h2mix=BF*si.h+(1-BF)*h_adp,w2mix=BF*si.w+(1-BF)*w_adp;T2=T_hw(h2mix,w2mix);w2=w2mix;params.ADPu=ADP;params.BFu=BF;note="Enfriar (condensación ADP+BF)";}}else if(t==="hum_adiab"){const typ=(params.humType||'adiab'),desc=(params.desc||'aRH');color="#10B981";if(typ==='adiab'){const hc=si.h;if(desc==='aRH'){const phi=Math.max(1,Math.min(100,isFinite(+params.phi)?+params.phi:50));T2=solveT(hc,phi,P);w2=wTRP(T2,phi,P);RH2=phi;note="Humidificación adiabática a φ";}else if(desc==='dx'){const dx=(isFinite(+params.dx_gpkg)?+params.dx_gpkg:0)/1000;let w_try=si.w+dx;let T_try=T_hw(hc,w_try);let RH_try=100*((w_try*P)/(0.62198+w_try))/pws(T_try);if(RH_try>100){const phi=99.9;T2=solveT(hc,phi,P);w2=wTRP(T2,phi,P);RH2=phi;}else{T2=T_try;w2=w_try;RH2=RH_try;}note="Humidificación adiabática Δx";}else if(desc==='mwater'){const mdw=Math.max(0,isFinite(+params.mw_lh)?+params.mw_lh:0)/3600;const dw=(md>0)?(mdw/md):0;let w_try=si.w+dw;let T_try=T_hw(hc,w_try);let RH_try=100*((w_try*P)/(0.62198+w_try))/pws(T_try);if(RH_try>100){const phi=99.9;T2=solveT(hc,phi,P);w2=wTRP(T2,phi,P);RH2=phi;}else{T2=T_try;w2=w_try;RH2=RH_try;}note="Humidificación adiabática ṁ agua";}}else if(typ==='iso'){T2=si.T;if(desc==='aRH'){const phi=Math.max(1,Math.min(100,isFinite(+params.phi)?+params.phi:50));w2=wTRP(T2,phi,P);RH2=phi;note="Humidificación isotérmica a φ";}else if(desc==='dx'){const dx=(isFinite(+params.dx_gpkg)?+params.dx_gpkg:0)/1000;const w_sat=wTRP(T2,100,P);w2=Math.min(si.w+dx,w_sat);note="Humidificación isotérmica Δx";}else if(desc==='mwater'){const mdw=Math.max(0,isFinite(+params.mw_lh)?+params.mw_lh:0)/3600;const dw=(md>0)?(mdw/md):0;const w_sat=wTRP(T2,100,P);w2=Math.min(si.w+dw,w_sat);note="Humidificación isotérmica ṁ agua";}}}else if(t==="dehum_coil"){T2=+params.T2||12;w2=Math.min(si.w,wTRP(T2,100,P));RH2=100*((w2*P)/(0.62198+w2))/pws(T2);note="Deshumidificación (coil)";color="#A855F7"}else if(t==="hrv"||t==="erv"){let rT,rW;if(params.ret){const r=S.find(s=>s.id===params.ret);if(!r)return alert("Retorno inválido");rT=r.T;rW=r.w;}else if(isFinite(+params.Tsec)&&isFinite(+params.RHsec)){rT=+params.Tsec;rW=wTRP(rT,+params.RHsec,P);}else{return alert("Define T secundaria y Hr secundaria.");}const eS=isFinite(+params.etaS)?+params.etaS:0;T2=si.T+eS*(rT-si.T);w2=si.w;if(t==="erv"){const eL=isFinite(+params.etaL)?+params.etaL:0;w2=si.w+eL*(rW-si.w);}RH2=Math.max(0,Math.min(100,100*((w2*P)/(0.62198+w2))/pws(T2)));note=(t==="erv"?"Recup. calor+humedad":"Recup. calor");color="#F97316"}else if(t==="evap_d"){const ph=Math.min(99.9,+params.phiMax||90),hc=si.h;T2=solveT(hc,ph,P);w2=wTRP(T2,ph,P);RH2=ph;note="Evap. directo";color="#14B8A6"}else if(t==="evap_i"){const eps=+params.eps||0.65,Twb=+params.Twb||18;T2=si.T-eps*(si.T-Twb);w2=si.w;RH2=100*((w2*P)/(0.62198+w2))/pws(T2);note="Evap. indirecto";color="#0EA5E9"}RH2=Math.max(0,Math.min(100,100*((w2*P)/(0.62198+w2))/pws(T2)));const st=addS(outName,T2,RH2,note);const seq=PROC_SEQ++;let badge=t;if(t==="hum_adiab"){const typ2=(params.humType||'adiab');badge=(typ2==='iso'?'hum_isot':'hum_adiab');}const p={id:"PP"+(ID++),type:t,badge,seq,in:[si.id],out:st.id,params,mdot:md,Q:0,M:0,color};const h2=hTw(T2,w2),h2_sen=hTw(T2,si.w);p.Q=md*(h2-si.h);p.M=md*(w2-si.w);p.Qsen=md*(h2_sen-si.h);p.Qlat=p.Q-p.Qsen;p.SHR=(Math.abs(p.Q)>1e-9)?(p.Qsen/p.Q):1;PR.push(p);recalc();return p;}
function csv(){const s=';';const nameOf=id=>{const ss=S.find(u=>u.id===id);return ss?(ss.name||ss.id):id};let c = '# ' + t('ui.project') + '\n';c += [ t('ui.altitude'), t('ui.pressure'), t('ui.airflow') ].join(s) + '\n';c += [ ALT.toFixed(0), (Pk??Pnow()).toFixed(3), (FLOW_M3H??'') ].join(s) + '\n\n';c += '# ' + t('ui.states') + '\n';c += [t('print.states.cols.name'),t('print.states.cols.t'),t('print.states.cols.rh'),t('print.states.cols.x'),t('print.states.cols.h'),t('print.states.cols.twb'),t('print.states.cols.rho'),'v (m³/kg)',t('print.states.cols.P'),t('print.states.cols.note')].join(s) + '\n';for(const x of S){c+=[(x.name||x.id),x.T.toFixed(2),x.RH.toFixed(2),(x.w*1000).toFixed(3),x.h.toFixed(3),x.Twb.toFixed(2),x.rho.toFixed(4),x.v.toFixed(5),x.P.toFixed(3),(x.note||'')].join(s)+'\n'}c += '\n# ' + t('ui.processes') + '\n';c += [t('print.procs.cols.proc'),t('print.procs.cols.type'),t('print.procs.cols.in'),t('print.procs.cols.out'),t('proc.k.dT') + ' (°C)',t('proc.k.dx') + ' (g/kg_da)',t('proc.k.dh') + ' (kJ/kg_da)',t('proc.k.m_lh') + ' (L/h)',t('print.procs.cols.Qt'),t('print.procs.cols.Qs')].join(s) + '\n';for(const p of PR){if(p.type==='state')continue;const inputs=Array.isArray(p.in)?p.in.map(nameOf).join(' + '):nameOf(p.in);const output=nameOf(p.out);const si=S.find(ss=>ss.id==(Array.isArray(p.in)?p.in[0]:p.in)),so=S.find(ss=>ss.id===p.out);const dT=(si&&so)?(so.T-si.T):0;const dx=(si&&so)?((so.w-si.w)*1000):0;const dh=(si&&so)?(so.h-si.h):0;const m_lh=(p.M||0)*3600;const Qtot=(p.Q||0),Qsen=(p.Qsen||0);const tipo=p.badge||(p.params&&p.params.humType==='iso'?'hum_isot':p.type);const procLabel=`${t('proc.label')}${p.seq||'?'}`;c+=[procLabel,tipo,inputs,output,dT.toFixed(2),dx.toFixed(3),dh.toFixed(3),m_lh.toFixed(2),Qtot.toFixed(3),Qsen.toFixed(3)].join(s)+'\n'}return c}
function dl(name,content,m='text/plain'){try{const b=new Blob([content],{type:m}),u=URL.createObjectURL(b),a=document.createElement('a');a.href=u;a.download=name;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(u),1000);}catch(e){const data='data:'+m+';charset=utf-8,'+encodeURIComponent(content);window.open(data,'_blank');}}
function rhCurves(P,step){
  const tr=[];
  for(let phi=step;phi<=100;phi+=step){
    const xs=[],ys=[];
    for(let T=-10;T<=50;T+=1){
      const w=wTRP(T,phi,P),h=hTw(T,w);
      xs.push(T);
      ys.push(w*1000)
    }
    tr.push({
      x:xs,y:ys,
      type:'scatter',mode:'lines',
      line:{color:'#E5E7EB',width:1,dash:phi===100?'dash':'solid'},
      hoverinfo:'none',showlegend:false
    });
  }
  return tr
}
function rhLabels(P){
  const labels = [10,30,50,70,90];
  const Tlab = 35;
  const out = [];
  for (const phi of labels){
    const w = wTRP(Tlab, phi, P);
    out.push({
      x:[Tlab], y:[w*1000],
      type:'scatter', mode:'text',
      text:[`${phi}%`],
      textposition:'top left',
      textfont:{ size:10, color:'#9CA3AF' },
      hoverinfo:'skip', showlegend:false
    });
  }
  return out;
}
function enthalpyLines(P, hMin=0, hMax=100, step=10){
  const tr = [];
  for (let h = hMin; h <= hMax; h += step){
    const xs = [], ys = [];
    for (let T = -10; T <= 50; T += 1){
      const denom = (2501 + 1.86*T);
      const w = Math.max(0, (h - 1.006*T)/denom);  // kg/kg
      const wsat = wTRP(T, 100, P);                 // saturación
      if (!isFinite(w) || w <= 0 || w*1000 > wsat*1000) {
        xs.push(null); ys.push(null);               // rompe el trazo fuera de envolvente
      } else {
        xs.push(T); ys.push(w*1000);                // g/kg
      }
    }
    tr.push({
      x: xs, y: ys,
      type:'scatter', mode:'lines',
      line:{ width:1, dash:'dot', color:'#C4A29E' }, // tono marrón/rojizo suave
      hoverinfo:'none', showlegend:false
    });

    // Etiqueta numérica "h" (kJ/kg) colocada a la izquierda
    const Tlab = 0;
    const wlab = Math.max(0,(h - 1.006*Tlab)/(2501 + 1.86*Tlab));
    const wsatlab = wTRP(Tlab, 100, P);
    if (wlab > 0 && wlab < wsatlab){
      tr.push({
        x:[Tlab+0.5], y:[wlab*1000],
        type:'scatter', mode:'text',
        text:[String(h)],
        textposition:'bottom right',
        textfont:{ size:10, color:'#C4A29E' },
        hoverinfo:'skip', showlegend:false
      });
    }
  }
  return tr;
}
function draw(step){
  const P=Pnow(), tr=[];
  if(window.SHOW_RH){
    tr.push(...rhCurves(P,step));
    tr.push(...rhLabels(P));
    tr.push(...enthalpyLines(P, 0, 100, 10));
  }

  // Líneas de procesos + ayudas visuales
  for(const p of PR){
    if(p.type==='state') continue;
    const si = S.find(s=>s.id==(Array.isArray(p.in)?p.in[0]:p.in));
    const so = S.find(s=>s.id===p.out);
    if(!si||!so) continue;

    // Línea principal del proceso
    const lineColor = (p.type==='mix') ? '#065F46' : (p.color||'#6B7280');
    tr.push({
      x:[si.T,so.T], y:[si.w*1000,so.w*1000],
      type:'scatter', mode:'lines',
      line:{color:lineColor,width:3},
      hoverinfo:'none', showlegend:false
    });    

    // Helper para MEZCLA: punto gris del nuevo caudal + línea discontinua al resultado
    if(p.type==='mix' && p.params && isFinite(p.params.Tn) && isFinite(p.params.RHn)){
      const Tn=+p.params.Tn, RHn=+p.params.RHn;
      const wNew = wTRP(Tn,RHn,P);
      tr.push({x:[Tn],y:[wNew*1000],type:'scatter',mode:'markers',marker:{color:'#D1D5DB',size:9,line:{color:'#9CA3AF',width:1}},hoverinfo:'skip',showlegend:false});
      tr.push({x:[Tn,so.T],y:[wNew*1000,so.w*1000],type:'scatter',mode:'lines',line:{color:'#D1D5DB',width:2,dash:'dot'},hoverinfo:'none',showlegend:false});
    }

    // Helper para RECUPERACIÓN (HRV/ERV): punto gris del secundario + línea discontinua al resultado
    if((p.type==='hrv'||p.type==='erv') && p.params){
      let Taux=null, wAux=null;
      if(isFinite(p.params.Tsec) && isFinite(p.params.RHsec)){
        Taux=+p.params.Tsec; wAux=wTRP(Taux,+p.params.RHsec,P);
      }else if(p.params.ret){
        const r=S.find(s=>s.id===p.params.ret); if(r){Taux=r.T; wAux=r.w;}
      }
      if(Taux!=null && isFinite(wAux)){
        tr.push({x:[Taux],y:[wAux*1000],type:'scatter',mode:'markers',marker:{color:'#D1D5DB',size:9,line:{color:'#9CA3AF',width:1}},hoverinfo:'skip',showlegend:false});
        tr.push({x:[Taux,so.T],y:[wAux*1000,so.w*1000],type:'scatter',mode:'lines',line:{color:'#D1D5DB',width:2,dash:'dot'},hoverinfo:'none',showlegend:false});
      }
    }

    // Helper para ENFRIAR con condensación: punto ADP y línea discontinua al resultado
    if(p.type==='cool' && p.params && isFinite(p.params.ADPu)){
      const ADP=+p.params.ADPu;
      const wADP = wTRP(ADP,100,P);
      tr.push({x:[ADP],y:[wADP*1000],type:'scatter',mode:'markers',marker:{color:'#D1D5DB',size:9,line:{color:'#9CA3AF',width:1}},hoverinfo:'skip',showlegend:false});
      tr.push({x:[ADP,so.T],y:[wADP*1000,so.w*1000],type:'scatter',mode:'lines',line:{color:'#D1D5DB',width:2,dash:'dot'},hoverinfo:'none',showlegend:false});
    }
  }

  // Estados (puntos azules con etiquetas)
  const xs=S.map(s=>s.T),
        ys=S.map(s=>s.w*1000),
        nameTxt=S.map(s=>`${s.name||s.id}`),
        hoverTxt=S.map(s=>`${s.name||s.id}`+`<br>T=${s.T.toFixed(1)}°C · φ=${s.RH.toFixed(0)}%`+`<br>x=${(s.w*1000).toFixed(2)} g/kg · h=${s.h.toFixed(2)} kJ/kg`+`<br>Twb=${s.Twb.toFixed(1)}°C · ρ=${s.rho.toFixed(3)} kg/m³`);
  tr.push({x:xs,y:ys,text:nameTxt,hovertext:hoverTxt,type:'scatter',mode:'markers+text',marker:{color:'#22D3EE',size:10,line:{color:'#0891B2',width:2}},textposition:'top right',textfont:{size:12},hovertemplate:'%{hovertext}<extra></extra>',showlegend:false});


  // Layout y render
  const layout={
    xaxis:{title:'Tbs (°C)', range:[-10,50], gridcolor:'#E5E7EB', zeroline:false},
    yaxis:{title:'x (g/kg_da)', range:[0,26], gridcolor:'#E5E7EB', zeroline:false},
    margin:{l:64,r:24,t:32,b:56},
    dragmode:'pan', plot_bgcolor:'#F9FAFB', paper_bgcolor:'#FFFFFF', font:{size:12}
  };
  Plotly.newPlot('plot',tr,layout,{responsive:true,displaylogo:false});

  // Click: seleccionar estado más cercano
  document.getElementById('plot').on('plotly_click',ev=>{
    if(!ev.points||!ev.points.length) return;
    let T=ev.points[0].x, y=ev.points[0].y, b=null, d=1e9;
    for(const s of S){ const dd=Math.hypot(s.T-T,(s.w*1000)-y); if(dd<d){d=dd; b=s;} }
    if(b){ SEL=b.id; renderLists(); }
  });
}

function renderLists(){
  const st=document.getElementById('stateList'), pr=document.getElementById('procList');
  st.innerHTML = S.map(s=>`<div class="row${s.id===SEL?' selected':''}" data-id="${s.id}">
    <div style="flex:1">
      <strong>${s.name||s.id}</strong>
      <div class="muted">T=${s.T.toFixed(1)}°C · φ=${s.RH.toFixed(1)}% · x=${(s.w*1000).toFixed(2)} g/kg · h=${s.h.toFixed(2)} kJ/kg · Twb=${s.Twb.toFixed(1)}°C · ρ=${s.rho.toFixed(3)} kg/m³</div>
    </div>
    <div class="actions">
      <button class="del" data-i18n="btn.delete"></button>
    </div>
  </div>`).join('');

  pr.innerHTML = PR.filter(p=>p.type!=='state').map(p=>{
    const nameOf=(id)=>{const s=S.find(x=>x.id===id);return s?(s.name||s.id):id;};
    const firstIn = Array.isArray(p.in)? p.in[0] : p.in;
    const si = S.find(s=>s.id===firstIn), so = S.find(s=>s.id===p.out);
    const inLabel = Array.isArray(p.in) ? p.in.map(nameOf).join(' + ') : nameOf(p.in);
    const outLabel = nameOf(p.out);
    // Deltas (si tenemos estados válidos)
    const dT = (si&&so) ? (so.T - si.T) : 0;
    const dx = (si&&so) ? ((so.w - si.w)*1000) : 0;           // g/kg_da
    const dh = (si&&so) ? (so.h - si.h) : 0;                  // kJ/kg_da
    const m_lh = (p.M||0)*3600;                               // L/h ≈ kg/h
    const Qtot = (p.Q||0), Qsen = (p.Qsen||0);
    const badge = p.badge || p.type;                          // hum_isot / hum_adiab / cool / heat / mix / hrv / erv
    return `<div class="row">
      <div>
        <strong>${t('proc.label')}${p.seq||'?'}</strong> <span class="badge">${badge}</span>
        <div class="muted">
          ${t('ui.input')}: ${inLabel} → ${t('ui.output')}: ${outLabel}
        </div>
        <div class="muted">
          ${t('proc.k.dT')}=${dT.toFixed(1)} °C ·
          ${t('proc.k.dx')}=${dx.toFixed(2)} g/kg ·
          ${t('proc.k.dh')}=${dh.toFixed(2)} kJ/kg_da ·
          ${t('proc.k.m_lh')}=${m_lh.toFixed(1)} L/h ·
          ${t('proc.k.Qtot')}=${Qtot.toFixed(2)} kW ·
          ${t('proc.k.Qsen')}=${Qsen.toFixed(2)} kW
        </div>
      </div>
    </div>`;
  }).join('');
}

async function exportPDF(){
  try{
    // 1) Crear contenedor limpio
    const old=document.getElementById('printArea'); if(old) old.remove();
    const box=document.createElement('div'); box.id='printArea'; document.body.appendChild(box);

    // --------- PÁGINA 1: GRÁFICA ----------
    const p1=document.createElement('section'); p1.className='print-page print-plot';
    const h1a=document.createElement('div'); h1a.className='h1'; h1a.textContent=t('print.title.diagram');
    const img=document.createElement('img'); img.alt=t('print.alt.plot');
    p1.appendChild(h1a); p1.appendChild(img);
    box.appendChild(p1);

    // Exportar la figura Plotly a PNG e insertarla
    if(typeof Plotly!=='undefined' && document.getElementById('plot')){
      // asegura que la gráfica esté actualizada
      if(typeof draw==='function'){ draw(window.RH_STEP); }
      const dataUrl=await Plotly.toImage(document.getElementById('plot'),{format:'png',width:1400,height:900,scale:2});
      img.src=dataUrl;
    }else{
      // sin plot: deja un placeholder
      img.src=''; h1a.textContent='(No se encontró la gráfica)';
    }

    // --------- PÁGINA 2: TABLA DE ESTADOS ----------
    const p2=document.createElement('section'); p2.className='print-page';
    const h1b=document.createElement('div'); h1b.className='h1'; h1b.textContent=t('print.title.states');
    const tStates=buildStatesTable();
    p2.appendChild(h1b); p2.appendChild(tStates);
    box.appendChild(p2);

    // --------- PÁGINA 3: TABLA DE PROCESOS ----------
    const p3=document.createElement('section'); p3.className='print-page';
    const h1c=document.createElement('div'); h1c.className='h1'; h1c.textContent=t('print.title.procs');
    const tProcs=buildProcsTable();
    p3.appendChild(h1c); p3.appendChild(tProcs);
    box.appendChild(p3);

    // 2) Imprimir
    setTimeout(()=>window.print(),120); // pequeño delay para que cargue la imagen
  }catch(e){
    alert('No se pudo generar el PDF: '+e.message);
  }
}

function buildStatesTable(){
  const tbl=document.createElement('table'); tbl.className='print-table';
  tbl.innerHTML = `<thead><tr>
    <th>${t('print.states.cols.name')}</th>
    <th>${t('print.states.cols.t')}</th>
    <th>${t('print.states.cols.rh')}</th>
    <th>${t('print.states.cols.x')}</th>
    <th>${t('print.states.cols.h')}</th>
    <th>${t('print.states.cols.twb')}</th>
    <th>${t('print.states.cols.rho')}</th>
    <th>${t('print.states.cols.note')}</th>
  </tr></thead><tbody>${
    S.map(s=>`<tr>
      <td>${esc(s.name||s.id)}</td>
      <td>${s.T.toFixed(1)}</td>
      <td>${s.RH.toFixed(1)}</td>
      <td>${(s.w*1000).toFixed(2)}</td>
      <td>${s.h.toFixed(2)}</td>
      <td>${s.Twb.toFixed(1)}</td>
      <td>${s.rho.toFixed(3)}</td>
      <td>${esc(s.note||'')}</td>
    </tr>`).join('')
  }</tbody>`;
  return tbl;
}

function buildProcsTable(){
  const tbl=document.createElement('table'); tbl.className='print-table';
  const nameOf=(id)=>{const s=S.find(x=>x.id===id);return s?(s.name||s.id):id;};
  tbl.innerHTML = `<thead><tr>
    <th>${t('print.procs.cols.proc')}</th>
    <th>${t('print.procs.cols.type')}</th>
    <th>${t('print.procs.cols.in')}</th>
    <th>${t('print.procs.cols.out')}</th>
    <th>${t('proc.k.dT')} (°C)</th>
    <th>${t('proc.k.dx')} (g/kg_da)</th>
    <th>${t('proc.k.dh')} (kJ/kg_da)</th>
    <th>${t('proc.k.m_lh')} (L/h)</th>
    <th>${t('print.procs.cols.Qt')}</th>
    <th>${t('print.procs.cols.Qs')}</th>
  </tr></thead><tbody>${
    PR.filter(p=>p.type!=='state').map(p=>{
      const inputs = Array.isArray(p.in)? p.in.map(nameOf).join(' + ') : nameOf(p.in);
      const output = nameOf(p.out);
      const si = S.find(s=>s.id==(Array.isArray(p.in)?p.in[0]:p.in));
      const so = S.find(s=>s.id===p.out);
      const dT = (si&&so)? (so.T-si.T) : 0;
      const dx = (si&&so)? ((so.w-si.w)*1000) : 0;
      const dh = (si&&so)? (so.h-si.h) : 0;
      const m_lh = (p.M||0)*3600; // ~ L/h
      const Qtot = (p.Q||0), Qsen=(p.Qsen||0);
      const tipo = p.badge || (p.params&&p.params.humType==='iso'?'hum_isot':p.type);
      const label = (typeof p.seq!=='undefined')?`Proceso_${p.seq}`:(p.id||'Proceso');
      return `<tr>
        <td>${esc(label)}</td><td>${esc(tipo)}</td><td>${esc(inputs)}</td><td>${esc(output)}</td>
        <td>${dT.toFixed(1)}</td><td>${dx.toFixed(2)}</td><td>${dh.toFixed(2)}</td>
        <td>${m_lh.toFixed(1)}</td><td>${Qtot.toFixed(2)}</td><td>${Qsen.toFixed(2)}</td>
      </tr>`;
    }).join('')
  }</tbody>`;
  return tbl;
}

function exportDataJSON(){const nameOf=id=>{const s=S.find(x=>x.id===id);return s?(s.name||s.id):id};const states=S.map(s=>({name:(s.name||s.id),Tdb_C:+s.T.toFixed(2),RH_pct:+s.RH.toFixed(2),x_g_per_kg:+(s.w*1000).toFixed(3),h_kJ_per_kg:+s.h.toFixed(3),Twb_C:+s.Twb.toFixed(2),rho_kg_m3:+s.rho.toFixed(4),v_m3_kg:+s.v.toFixed(5),P_kPa:+s.P.toFixed(3),note:(s.note||'')}));const processes=PR.filter(p=>p.type!=='state').map(p=>{const inputsArr=Array.isArray(p.in)?p.in.map(nameOf):[nameOf(p.in)];const output=nameOf(p.out);const si=S.find(ss=>ss.id==(Array.isArray(p.in)?p.in[0]:p.in));const so=S.find(ss=>ss.id===p.out);const dT=(si&&so)?(so.T-si.T):0;const dx=(si&&so)?((so.w-si.w)*1000):0;const dh=(si&&so)?(so.h-si.h):0;const m_lh=(p.M||0)*3600;const Qtot=(p.Q||0),Qsen=(p.Qsen||0);const tipo=p.badge||(p.params&&p.params.humType==='iso'?'hum_isot':p.type);return{process:`Process_${p.seq||'?'}`,type:tipo,inputs:inputsArr,output:output,deltaT_C:+dT.toFixed(2),deltaX_g_per_kg:+dx.toFixed(3),deltaH_kJ_per_kg:+dh.toFixed(3),m_water_L_h:+m_lh.toFixed(2),Q_total_kW:+Qtot.toFixed(3),Q_sensible_kW:+Qsen.toFixed(3),params:p.params||{}}});const out={project:{altitude_m:ALT,pressure_kPa:(Pk??Pnow()),flow_m3h:FLOW_M3H},states,processes};dl('psychro_export.json',JSON.stringify(out,null,2),'application/json')}

// Utilidad simple para evitar HTML accidental en nombres/notas
function esc(s){return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}

function bind(){document.getElementById('stateList')?.addEventListener('click',e=>{const row=e.target.closest('.row');if(!row)return;const id=row.dataset.id;if(e.target.classList.contains('del')){if(confirm(t('confirm.delete'))){delS(id);recalc();renderLists();draw(window.RH_STEP);}}});
 document.getElementById('addState')?.addEventListener('click',()=>{const T=parseFloat(document.getElementById('sT').value),RH=parseFloat(document.getElementById('sRH').value),n=document.getElementById('sName').value||'',b=document.getElementById('sNote').value||'';if(isNaN(T)||isNaN(RH))return alert('Introduce T y φ');if(RH<0||RH>100)return alert('φ 0..100');const nameClean=(n||'').trim();if(!nameClean)return alert('Pon un nombre para el estado');if(S.some(s=>(s.name||'').trim().toLowerCase()===nameClean.toLowerCase()))return alert('Ese nombre ya existe. Elige otro.');addS(nameClean,T,RH,b);recalc();renderLists();if(typeof Plotly!=='undefined')draw(window.RH_STEP);});
 document.getElementById('doProc')?.addEventListener('click',()=>{const t=document.getElementById('procType').value;if(!t||t==='select'){return;}if(FLOW_M3H==null||isNaN(FLOW_M3H)||FLOW_M3H<=0){return alert('Introduce un caudal de aire en Condiciones (m³/h).');}const on=document.getElementById('procOutName').value||'P';if(t==='mix'){const inId=document.getElementById('procIn').value;const Tn=parseFloat(document.getElementById('pmixT').value);const RHn=parseFloat(document.getElementById('pmixRH').value);const qN=parseFloat(document.getElementById('pmixQ').value);const pctUse=parseFloat(document.getElementById('pmixPctUse').value);if([Tn,RHn,qN,pctUse].some(v=>isNaN(v)))return alert('Completa todos los parámetros de mezcla.');if(RHn<0||RHn>100)return alert('HR 0..100%');if(pctUse<0||pctUse>100)return alert('% caudal existente para mezcla debe estar entre 0 y 100.');const st=mixWithNew(inId,Tn,RHn,qN,pctUse,on);if(!st)return;recalc();renderLists();if(typeof Plotly!=='undefined')draw(window.RH_STEP);return;}let tEngine=t,ps={};if(t==='rc')tEngine='hrv';if(t==='humid')tEngine='hum_adiab';const inp=document.getElementById('procIn').value;if(t==='heat'||t==='cool'){const desc=document.getElementById('p_desc')?.value||'dT';ps.desc=desc;if(desc==='Q'){ps.QkW=parseFloat(document.getElementById('p_Q').value||0);}else if(desc==='dT'){ps.dT=parseFloat(document.getElementById('p_dT').value||0);}else if(desc==='dH'){ps.dH=parseFloat(document.getElementById('p_dH').value||0);}else if(desc==='aT'){ps.Ttarget=parseFloat(document.getElementById('p_Ttarget').value||NaN);}else if(desc==='Twall'){ps.Twall=parseFloat(document.getElementById('p_Twall').value||NaN);if(t==='heat'){const e=document.getElementById('p_etaCoil');if(e)ps.eta=parseFloat(e.value||0.7);}}else if(desc==='hyd'){ps.Tw_in=parseFloat(document.getElementById('p_Twin').value||NaN);ps.Tw_out=parseFloat(document.getElementById('p_Twout').value||NaN);if(t==='heat'){const e=document.getElementById('p_etaCoil');if(e)ps.eta=parseFloat(e.value||0.7);}}const dADPel=document.getElementById('p_dADP');const BFovEl=document.getElementById('p_BFov');const dADP=parseFloat(dADPel?.value);if(!isNaN(dADP))ps.dADP=dADP;const BFov=parseFloat(BFovEl?.value);if(!isNaN(BFov))ps.BFov=BFov;const etaAllEl=document.getElementById('p_etaAllCool');if(t==='cool'&&etaAllEl)ps.etaAll=((parseFloat(etaAllEl.value)||80)/100);}else if(t==='rc'){const Tsec=parseFloat(document.getElementById('p_Tsec')?.value);const RHsec=parseFloat(document.getElementById('p_RHsec')?.value);const etaS_pct=parseFloat(document.getElementById('p_etaS_rc')?.value);const etaL_pct=parseFloat(document.getElementById('p_etaL_rc')?.value);if([Tsec,RHsec,etaS_pct,etaL_pct].some(v=>isNaN(v)))return alert('Completa T secundaria, Hr secundaria y eficiencias.');if(RHsec<0||RHsec>100)return alert('Hr secundaria 0..100%');if(etaS_pct<0||etaS_pct>100)return alert('Eficiencia térmica 0..100%');if(etaL_pct<0||etaL_pct>100)return alert('Recup. de humedad 0..100%');ps.Tsec=Tsec;ps.RHsec=RHsec;ps.etaS=etaS_pct/100;ps.etaL=etaL_pct/100;tEngine=(ps.etaL>0)?'erv':'hrv';}else if(t==='humid'){ps.humType=(document.getElementById('humType')?.value||'adiab');ps.desc=(document.getElementById('humDesc')?.value||'aRH');if(ps.desc==='dx'){ps.dx_gpkg=parseFloat(document.getElementById('p_dx')?.value);}else if(ps.desc==='aRH'){ps.phi=parseFloat(document.getElementById('p_phi')?.value);}else if(ps.desc==='mwater'){ps.mw_lh=parseFloat(document.getElementById('p_mw_lh')?.value);}tEngine=(ps.humType==='adiab'?'hum_adiab':'hum_iso');}const p=proc(tEngine,inp,ps,null,on);if(p){renderLists();if(typeof Plotly!=='undefined')draw(window.RH_STEP);}});
 document.getElementById('procType')?.addEventListener('change',()=>{ renderProcParams(); toggleProcUI(); });
 document.getElementById('saveJSON')?.addEventListener('click',()=>dl('psychro_project.json',JSON.stringify({altitude_m:ALT,pressure_kPa:Pk,flow_m3h:FLOW_M3H,states:S,processes:PR},null,2),'application/json'));
 document.getElementById('loadJSON')?.addEventListener('click',()=>{const i=document.createElement('input');i.type='file';i.accept='.json,application/json';i.onchange=()=>{const f=i.files[0];if(!f)return;const r=new FileReader();r.onload=()=>{try{const P=JSON.parse(r.result);ALT=(P.altitude_m??ALT);Pk=(P.pressure_kPa??Pk);FLOW_M3H=(P.flow_m3h??FLOW_M3H);const qEl=document.getElementById('q_m3h');if(qEl)qEl.value=(FLOW_M3H??'');S=P.states||[];PR=P.processes||[];PR=PR.map(p=>{if(p&&(p.type==='dehum'||p.type==='dehum_coil')){const T2=isFinite(p.params?.T2)?+p.params.T2:12;return {...p,type:'cool',params:{...(p.params||{}),desc:'aT',Ttarget:T2,etaAll:1,BFov:0,dADP:0}}}return p;});let k=1;PR=PR.map(p=>{if(p&&p.type!=='state'){const badge=p.badge?p.badge:(p.type==='hum_adiab'&&p.params&&p.params.humType==='iso'?'hum_isot':p.type);return {...p,seq:k++,badge};}return p;});PROC_SEQ=k;recalc();renderLists();draw(window.RH_STEP);}catch(e){alert('JSON no válido')}};r.readAsText(f)};i.click();});
 document.getElementById('exportJSON')?.addEventListener('click',()=>exportDataJSON());
 document.getElementById('exportCSV')?.addEventListener('click',()=>dl('psychro_export.csv',csv(),'text/csv'));
 document.getElementById('exportCSV_m')?.addEventListener('click',()=>dl('psychro_export.csv',csv(),'text/csv'));
 document.getElementById('exportPDF')?.addEventListener('click',()=>exportPDF());
 document.getElementById('printPDF_m')?.addEventListener('click',()=>window.print());
 document.getElementById('altPreset')?.addEventListener('change',()=>{ALT=parseFloat(document.getElementById('altPreset').value);infoP();});
 document.getElementById('pressure')?.addEventListener('input',()=>{const v=parseFloat(document.getElementById('pressure').value);Pk=isNaN(v)?null:v;infoP();});
 document.getElementById('q_m3h')?.addEventListener('input',()=>{const v=parseFloat(document.getElementById('q_m3h').value);FLOW_M3H=isNaN(v)?null:v;infoP();});
}
function infoP(){recalc();renderLists();if(typeof Plotly!=='undefined')draw(window.RH_STEP);}

function renderProcParams(){
  const ptype=document.getElementById('procType').value;
  if(!t || t==='select'){
    document.getElementById('procParams').innerHTML='';
    toggleProcUI();
    return;
  }
  // helper: genera los campos específicos para "Calentar" según "desc"
  const heatFields = (desc)=>{
    if(desc==='Q'){ // Potencia
      return `<div><label>Potencia (kW)</label><input id="p_Q" type="number" step="0.01" value="5"></div>`;
    }else if(desc==='dT'){ // ΔT
      return `<div><label>ΔT (K)</label><input id="p_dT" type="number" step="0.1" value="5"></div>`;
    }else if(desc==='dH'){ // Δh
      return `<div><label>Δh (kJ/kg_da)</label><input id="p_dH" type="number" step="0.1" value="5"></div>`;
    }else if(desc==='aT'){ // a T
      return `<div><label>T objetivo (°C)</label><input id="p_Ttarget" type="number" step="0.1" value="35"></div>`;
    }else if(desc==='Twall'){ // T pared + eficiencia
      return `<div><label>T pared (°C)</label><input id="p_Twall" type="number" step="0.1" value="45"></div>`;
    }else if(desc==='hyd'){ // Caract. medio hyd.
      return `<div><label>T agua IN (°C)</label><input id="p_Twin" type="number" step="0.1" value="60"></div>
              <div><label>T agua OUT (°C)</label><input id="p_Twout" type="number" step="0.1" value="50"></div>`;
    }
    return '';    
  };
  const coolFields=(desc)=>{
    if(desc==='Q'){ return `<div><label>Potencia (kW)</label><input id="p_Q" type="number" step="0.01" value="5"></div>`; }
    if(desc==='dT'){ return `<div><label>ΔT (K)</label><input id="p_dT" type="number" step="0.1" value="-5"></div>`; }
    if(desc==='dH'){ return `<div><label>Δh (kJ/kg_da)</label><input id="p_dH" type="number" step="0.1" value="5"></div>`; }
    if(desc==='aT'){ return `<div><label>T objetivo (°C)</label><input id="p_Ttarget" type="number" step="0.1" value="15"></div>`; }
    if(desc==='Twall'){ return `<div><label>T pared (°C)</label><input id="p_Twall" type="number" step="0.1" value="10"></div>`; }
    if(desc==='hyd'){ return `<div><label>T agua IN (°C)</label><input id="p_Twin" type="number" step="0.1" value="7"></div><div><label>T agua OUT (°C)</label><input id="p_Twout" type="number" step="0.1" value="12"></div>`; }
    return '';
  };

  let h='';
  if(ptype==='heat'){
    h = `<div><label>${t('proc.field.calc_by')}</label>
          <select id="p_desc">
            <option value="Q">${t('proc.by.Q')}</option>
            <option value="dT" selected>ΔT</option>
            <option value="dH">Δh</option>
            <option value="aT">${t('proc.by.aT')}</option>
            <option value="Twall">${t('proc.by.Twall')}</option>
            <option value="hyd">${t('proc.by.hyd')}</option>
          </select>
        </div>
        <div id="heatParams">${heatFields('dT')}</div>`;
  }
  else if(ptype==='cool'){
    h = `<div><label>${t('proc.field.calc_by')}</label>
          <select id="p_desc">
            <option value="Q">${t('proc.by.Q')}</option>
            <option value="dT" selected>ΔT</option>
            <option value="dH">Δh</option>
            <option value="aT">${t('proc.by.aT')}</option>
            <option value="Twall">${t('proc.by.Twall')}</option>
            <option value="hyd">${t('proc.by.hyd')}</option>
          </select>
        </div>
        <div id="heatParams">${coolFields('dT')}</div>
        <div><label>${t('proc.field.eta_cooler_pct')}</label><input id="p_etaAllCool" type="number" step="1" value="80"></div>`;
    h += `<div style="margin-top:6px;border-top:1px dashed #ccc;padding-top:6px">
        <div><label>${t('proc.field.dADP_K')}</label><input id="p_dADP" type="number" step="0.1" value="2"></div>
        <div><label>${t('proc.field.BFov')}</label><input id="p_BFov" type="number" step="0.01" placeholder=""></div>
        <small>${t('proc.cool.note_cond')}</small>
      </div>`;
  }
  else if (ptype === 'mix') {
    h = `
      <div class="row">
        <label>${t('proc.field.mix_Tn')}</label>
        <input id="p_mix_Tn" type="number" step="0.1">
      </div>
      <div class="row">
        <label>${t('proc.field.mix_RHn')}</label>
        <input id="p_mix_RHn" type="number" step="0.1">
      </div>
      <div class="row">
        <label>${t('proc.field.mix_qNew')}</label>
        <input id="p_mix_qNew" type="number" step="1">
      </div>
      <div class="row">
        <label>${t('proc.field.mix_pctUse')}</label>
        <input id="p_mix_pctUse" type="number" step="1">
      </div>
    `;
  }
  else if(ptype==='rc'){
    h = `<div><label>${t('proc.field.T_sec')}</label><input id="p_Tsec" ...></div>
        <div><label>${t('proc.field.RH_sec')}</label><input id="p_RHsec" ...></div>
        <div><label>${t('proc.field.etaS_pct')}</label><input id="p_etaS_rc" ...></div>
        <div><label>${t('proc.field.etaL_pct')}</label><input id="p_etaL_rc" ...></div>`;
  }
  else if(ptype==='humid'){
    h = `<div><label>${t('proc.field.hum_type')}</label>
          <select id="humType">
            <option value="adiab" selected>${t('proc.hum.adiab')}</option>
            <option value="iso">${t('proc.hum.iso')}</option>
          </select>
        </div>
        <div><label>${t('proc.field.hum_mode')}</label>
          <select id="humDesc">
            <option value="aRH" selected>${t('proc.hum.aRH')}</option>
            <option value="dx">${t('proc.hum.dx')}</option>
            <option value="mwater">${t('proc.hum.mwater')}</option>
          </select>
        </div>
        <div id="humidParams"></div>`;
  }
  
  document.getElementById('procParams').innerHTML = h;

  if(ptype==='heat'){
    const sel=document.getElementById('p_desc');
    sel?.addEventListener('change', (e)=>{
      const v = e.target.value;
      const box=document.getElementById('heatParams');
      if(box) box.innerHTML = heatFields(v);
    });
  }

  if(ptype==='cool'){
    const sel=document.getElementById('p_desc');
    sel?.addEventListener('change',(e)=>{
      const v=e.target.value;
      const box=document.getElementById('heatParams');
      if(box) box.innerHTML = coolFields(v);
    });
  }

  if(ptype==='humid'){
    const humFields = (typ, desc)=>{
      if(desc==='aRH')
        return `<div><label>${t('proc.field.phi_pct')}</label><input id="p_phi" ...></div>`;
      if(desc==='dx')
        return `<div><label>${t('proc.field.dx_gpkg')}</label><input id="p_dx" ...></div>`;
      if(desc==='mwater')
        return `<div><label>${t('proc.field.mw_lh')}</label><input id="p_mw_lh" ...></div>`;
      return '';
    };
    const selType=document.getElementById('humType');
    const selDesc=document.getElementById('humDesc');
    const box=document.getElementById('humidParams');
    if(box) box.innerHTML = humFields(selType?.value||'adiab', selDesc?.value||'aRH');
    selType?.addEventListener('change',()=>{ if(box) box.innerHTML = humFields(selType.value, selDesc.value); });
    selDesc?.addEventListener('change',()=>{ if(box) box.innerHTML = humFields(selType.value, selDesc.value); });
  }
 
  // Rellenar selects dependientes del tipo
  const opts=S.map(s=>`<option value="${s.id}">${s.name||s.id}</option>`).join('');
  const ret=document.getElementById('p_ret'); if(ret) ret.innerHTML=opts;
  const a=document.getElementById('pmixA'), b=document.getElementById('pmixB');
  if(a&&b){ a.innerHTML=opts; b.innerHTML=opts; }

  toggleProcUI();
}
function toggleProcUI(){const t = document.getElementById('procType').value;const show = !!t && t!=='select' && t!=='';['procInWrap','procParams','procOutWrap','doProc'].forEach(id=>{const el=document.getElementById(id); if(el) el.style.display = show ? '' : 'none';});const inSel=document.getElementById('procIn'); if(inSel) inSel.disabled = (!show);}
function init(step){window.RH_STEP=step; window.SHOW_RH=true; ADD_UI(); ALT=400; Pk=null; recalc(); renderLists(); infoP();}
</script>

<script>
function ADD_UI(){
  const app=document.body.querySelector('.app');
  const aside=document.createElement('aside'); aside.className='sidebar'; aside.id='sidebar';
  aside.innerHTML=`
  <h1 data-i18n="ui.project"></h1>
  <details class="card">
    <summary data-i18n="ui.conditions"></summary>
    <div class="card-body">
      <div class="grid cols-2">
        <div><label data-i18n="ui.altitude"></label>
          <select id="altPreset">
            <option value="0">0</option>
            <option value="400" selected>400</option>
            <option value="800">800</option>
            <option value="1200">1200</option>
          </select></div>
        <div><label data-i18n="ui.pressure"></label><input id="pressure" type="number" step="0.001" placeholder="auto"></div>
        <div><label data-i18n="ui.airflow"></label><input id="q_m3h" type="number" step="1" placeholder=""></div>
      </div>      
    </div>
  </details>
  <details class="card">
    <summary data-i18n="ui.newState"></summary>
    <div class="card-body">
      <div class="grid cols-2">
        <div><label data-i18n="ui.name"></label><input id="sName"></div>
        <div><label data-i18n="ui.note"></label><input id="sNote"></div>
        <div><label data-i18n="ui.tdb"></label><input id="sT" type="number" step="0.1" value="24"></div>
        <div><label data-i18n="ui.rh_pct"></label><input id="sRH" type="number" step="0.1" value="50"></div>
      </div>
      <button id="addState" data-i18n="btn.add"></button>
    </div>
  </details>
  <details class="card">
    <summary data-i18n="ui.newProc"></summary>
    <div class="card-body">
      <div class="grid">
        <div class="grid cols-2">
          <div><label data-i18n="ui.type"></label>
            <select id="procType">
              <option value="" selected data-i18n="proc.type.select"></option>
              <option value="heat" data-i18n="proc.type.heat"></option>
              <option value="cool" data-i18n="proc.type.cool"></option>
              <option value="mix" data-i18n="proc.type.mix"></option>
              <option value="rc" data-i18n="proc.type.rc"></option>
              <option value="humid" data-i18n="proc.type.humid"></option>
            </select></div>
          <div id="procInWrap"><label data-i18n="ui.input"></label><select id="procIn"></select></div>
        </div>
        <div id="procParams" class="grid cols-2"></div>
        <div id="procOutWrap" class="grid cols-2">        
          <div><label data-i18n="ui.output"></label><input id="procOutName" placeholder="P1"></div>                   
        </div>
        <button id="doProc" data-i18n="btn.apply"></button>
      </div>
    </div>
  </details>
  <details class="card">
    <summary data-i18n="ui.states"></summary>
    <div class="card-body"><div id="stateList" class="list"></div></div>
  </details>
  <details class="card">
    <summary data-i18n="ui.processes"></summary>
    <div class="card-body"><div id="procList" class="list"></div></div>
  </details>
  <details class="card">
    <summary data-i18n="ui.project"></summary>
    <div class="card-body">
      <div class="grid cols-2">
        <button id="saveJSON" data-i18n="btn.saveJson"></button>
        <button id="loadJSON" data-i18n="btn.loadJson"></button>
        <button id="exportCSV" data-i18n="btn.csv"></button>
        <button id="exportPDF" data-i18n="btn.pdf"></button>
        <button id="exportJSON" data-i18n="btn.jsonData"></button>
      </div>
    </div>
  </details>`;
  app.prepend(aside);

  const refreshSelects=()=>{
    ['procIn','pmixA','pmixB','p_ret'].forEach(id=>{
      const el=document.getElementById(id); if(!el) return;
      const keep=el.value;
      el.innerHTML = S.map(s=>`<option value="${s.id}">${s.name||s.id}</option>`).join('');
      if(keep && S.find(s=>s.id===keep)) el.value=keep;
    })
  };
  const _refresh=renderLists; 
  renderLists=()=>{ _refresh(); refreshSelects(); applyI18n(aside); }
  applyI18n(aside);
}
</script>

</head>
<body>
<div class="app">
  <section class="main">
    <div class="toolbar">
      <div style="flex:1"></div>

      <label class="muted" data-i18n="ui.lang"></label>
      <select id="langSel">
        <option value="es">ES</option>
        <option value="fr">FR</option>
        <option value="de">DE</option>
        <option value="it">IT</option>
        <option value="en">EN</option>
      </select>

      <label class="muted" data-i18n="toolbar.rh"></label>
      <select id="rhCurves">
        <option value="on"></option>
        <option value="off"></option>
      </select>

      <span class="muted" data-i18n="toolbar.ranges"></span>
    </div>
    <div id="plot"></div>
  </section>
</div>
<script>boot();</script>
</body></html>